良いコードを書く
===

オレオレ原則
--

1. メソッドを細かく切る（1 method 5 行以内にしたい）
2. SRP を徹底する
3. パブリックな入り口メソッドは宣言的記法を心がける。
4. 分散してる処理を一カ所にまとめる（Event の処理とかは FRP でやる）
5. 中身を隠してライブラリにする

SRP（Single Responsibility Principle）
---

メソッド、あるいはクラスの責務を一つだけにする。

####BEFORE

```rb
def do_hoge_and_fuga
  hoge1
  hoge2
  fuga1
  fuga2
  fuga3
end
```

hoge 処理と fuga 処理のどちらも面倒を見ることが責務になっており、役割が多過ぎる。
Exception が出た場合のハンドリングも複雑度が増している。
あんまり大したことしてなくてそんなに長くないメソッドだけど、分割した方が良い。

####AFTER

```rb
def do_hogefuga
  hoge
  fuga
end

def hoge
  hoge1
  hoge2
end

def fuga
  fuga1
  fuga2
  fuga3
end
```

`do_hogefuga` は `hoge` と `fuga` を呼ぶことだけが責務
`hoge` は hoge を完遂することが責務
`fuga` は fuga を完遂することが責務

([TODO] もっとまともなコード例を挙げる)

####ポイント

1. メソッドをとにかく細かく切る。
2. 「一つの責務」を深く掘って考える。
  * 「A をやって Exception があれば B」くらいの処理も一つにメソッドに入るのは責務が多い。
  * "A を呼んで Exception 出るか見守るメソッド", "A", "B" に分ける
3. 公開されているメソッドには private メソッドの呼び出ししか書いてない、くらいが良い。
4. 1 method 5 行以内, 多くても 10 行以内。どう考えても単一責任でない。
5. クラスも出来るだけバンバン分割する。

####利点

1. unit テストしやすい（逆に、分けなければ困難）
2. メソッド名がその内容を端的に表し、self-documented である
3. 1 メソッドが短くて読む人にやさしい（大きいメソッドはつらい）

####欠点

1. Dalvik の 65k に近づく (method call のオーバーヘッドはそんなにない)

コンポーネント化
---

意識しなくてよいことを増やす。

JSON ライブラリの中身は知らなくても JSON を使ったコードは書ける。
このように独立してかつ中身を知らなくてよいコード片を増やしていけば、頭で考える必要のある実コードは少なくなる。
呼び出す側（アプリケーション）は、呼び出し方だけ意識すればよい。
UI とか、同期処理とかそういったものはコンポーネント化されるべき。

コンポーネントの「呼び出し」は自然とコードが宣言的になるので、アプリの実コードも読みやすくなってよい。

また、状態と責務がそれぞれのコンポーネントで閉じる。
コンポーネントの状態の管理をコンポーネントに任せられる。
アプリは自身の状態だけ管理すればよい。

最終的に独立したコンポーネントの組み合わせだけでアプリが完成するくらいがよい。

####利点

1. unit テストがしやすい
2. 責務があやふやにならない。それぞれのコンポーネントの挙動は自身の責務

コメント
---

コメントが一切ないコードはつらい。
どんなに self-documented なコードでも、処理全体の流れは追わないと分からない。
従って、「処理全体の流れ」は最優先でコメントに書くべきことである。（あるいはドキュメント）
コードに現れない情報というのは掘ってみると沢山ある。

1. 処理全体がどういう流れになっているのか？
2. なぜこれを作ったのか？
3. なぜこういうコード / 処理の流れになったか？
4. どんな懸念点があるか？
5. このクラスはどういう責務を担っているのか？また、コード全体の中でどういう位置付けにあるのか？
6. どの URL を参照してこのコードを書いたか？

これらは出来るだけ考えたままにコメントに残すべきである。
メタ情報のコメントは多ければ多いほどいい。
